<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>this is our place</title>
 <style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: 'Segoe UI', sans-serif;
  }

  html, body {
    width: 100%;
    height: 100%;
    background: #0f1115;
    color: #e6eaf2;
  }

  .chat-container {
    width: 100vw;
    height: 100vh;
    background: linear-gradient(180deg, #141822, #0d111a);
    display: flex;
    flex-direction: column;
  }

  .chat-header {
    background-color: #141822;
    padding: 15px;
    color: #e6eaf2;
    font-size: 18px;
    font-weight: bold;
    text-align: center;
    position: sticky;
    top: 0;
    z-index: 10;
    border-bottom: 1px solid #22293a;
  }

  .messages {
    flex: 1;
    padding: 15px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background: #0f1115;
  }

  .message {
    max-width: 75%;
    padding: 10px 15px;
    border-radius: 20px;
    word-wrap: break-word;
    font-size: 15px;
    flex: 0 0 auto;
    width: fit-content;
    overflow-wrap: break-word;
  }

  .sent {
    align-self: flex-end;
    background-color: #1e2a44;
    color: #e6eaf2;
    border-bottom-right-radius: 0;
    border: 1px solid #2a3954;
  }

  .received {
    align-self: flex-start;
    background-color: #1b2333;
    color: #e6eaf2;
    border-bottom-left-radius: 0;
    border: 1px solid #1f2a3e;
  }

  .chat-input {
    display: flex;
    border-top: 1px solid #22293a;
    position: sticky;
    bottom: 0;
    z-index: 10;
    background-color: #141822;
  }

  #messageInput {
    flex: 1;
    padding: 10px;
    border: none;
    font-size: 16px;
    outline: none;
    background: #0f141d;
    color: #e6eaf2;
  }

  button {
    padding: 10px 20px;
    background-color: #5b8cff;
    color: white;
    border: none;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.3s;
  }

  input#messageInput {
    font-size: 16px; /* avoid zoom on mobile */
    min-height: 48px; /* easier to tap */
  }

  button {
    min-height: 48px;
    border-radius: 8px;
  }

  button:hover {
    background-color: #4674e9;
  }

#streak {
  text-shadow: none; /* no glow normally */
  transition: text-shadow 0.3s ease;
}

#streak.glow {
  text-shadow: 0 0 5px #ff6b00, 0 0 10px #ff4500, 0 0 15px #ff6b00; /* fire glow */
}

.timestamp {
  display: none;
  font-size: 11px;
  color: #aaa;
  margin-top: 4px;
  text-align: right;
}

.timestamp.show {
  display: block;
}

/* Reactions under messages */
.reactions {
  margin-top: 4px;
  display: flex;
  gap: 4px;
  font-size: 16px;
}

/* Emoji picker popup */
.emoji-picker {
  position: absolute;
  background: #1b2333;
  border: 1px solid #2a3954;
  border-radius: 12px;
  padding: 6px;
  display: flex;
  gap: 6px;
  z-index: 1000;
}

.emoji-picker button {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 20px;
}

.emoji-picker button:hover {
  transform: scale(1.2);
}

</style>

</head>
<body>
  <div class="chat-container">
    <div class="chat-header">
  <span id="streak" style="float: left;">🔥 0</span>
  💬 Just Us
</div>
    <div class="messages" id="messages"></div>
    <form class="chat-input" id="form">
      <input id="messageInput" autocomplete="off" placeholder="Someone's missing you..." />
      <button type="submit">Send</button>
    </form>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io({
      reconnection: true,
      reconnectionAttempts: 5
    });

    const form = document.getElementById('form');
    const input = document.getElementById('messageInput');
    const messages = document.getElementById('messages');


    let username = localStorage.getItem("username");

if (!username) {
  username = prompt("Enter your name")?.trim() || "User";
  localStorage.setItem("username", username);
}
    const EMOJIS = ['🤍','😅','😂','😮','😢','😭'];
let pickerEl = null;



    function addMessage(msg) {
  const msgDiv = document.createElement('div');
  msgDiv.classList.add('message');
  msgDiv.classList.add(msg.name === username ? 'sent' : 'received');
  msgDiv.dataset.id = msg._id; // keep messageId for reactions

  // Text node
  const textNode = document.createElement('div');
  textNode.textContent = msg.text;
  msgDiv.appendChild(textNode);

  // Timestamp
  const timeSpan = document.createElement('div');
  timeSpan.classList.add('timestamp');
  const date = new Date(msg.timestamp || Date.now());
  const options = { hour: 'numeric', minute: 'numeric', hour12: true };
  timeSpan.textContent = date.toLocaleTimeString([], options);
  msgDiv.appendChild(timeSpan);

  // Toggle timestamp on click
  msgDiv.addEventListener('click', () => {
    timeSpan.classList.toggle('show');
  });

  // Reaction container
  const reactionsDiv = document.createElement('div');
  reactionsDiv.classList.add('reactions');
  msgDiv.appendChild(reactionsDiv);

  // Right-click / long-press → open emoji picker
  msgDiv.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    showEmojiPicker(e.pageX, e.pageY, msg._id);
  });

  // Render existing reactions (if any)
  if (msg.reactions) renderReactions(msg._id, msg.reactions);

  messages.appendChild(msgDiv);
  messages.scrollTop = messages.scrollHeight;
}


function showEmojiPicker(x, y, messageId) {
  if (pickerEl) pickerEl.remove();

  pickerEl = document.createElement('div');
  pickerEl.classList.add('emoji-picker');
  pickerEl.style.left = x + 'px';
  pickerEl.style.top = y + 'px';

  EMOJIS.forEach(emoji => {
    const btn = document.createElement('button');
    btn.textContent = emoji;
    btn.onclick = () => {
      socket.emit('reaction:set', { messageId, user: username, emoji }, (res) => {
        if (!res.ok) alert("Failed to react: " + res.error);
      });
      pickerEl.remove();
      pickerEl = null;
    };
    pickerEl.appendChild(btn);
  });

  document.body.appendChild(pickerEl);

  // Close picker on outside click
  setTimeout(() => {
    document.addEventListener('click', closePickerOnce, { once: true });
  }, 0);

  function closePickerOnce() {
    if (pickerEl) pickerEl.remove();
    pickerEl = null;
  }
}

function renderReactions(messageId, reactions) {
  const msgDiv = document.querySelector(`.message[data-id="${messageId}"]`);
  if (!msgDiv) return;
  const reactionsDiv = msgDiv.querySelector('.reactions');
  reactionsDiv.innerHTML = '';

  // Group by emoji → count
  const counts = {};
  for (const [user, emoji] of Object.entries(reactions)) {
    counts[emoji] = (counts[emoji] || 0) + 1;
  }

  Object.entries(counts).forEach(([emoji, count]) => {
    const span = document.createElement('span');
    span.textContent = count > 1 ? `${emoji} ${count}` : emoji;
    if (reactions[username] === emoji) {
      span.style.outline = '1px solid #5b8cff';
      span.style.borderRadius = '6px';
      span.style.padding = '0 3px';
    }
    reactionsDiv.appendChild(span);
  });
}


// Typing indicator
let typingTimeout;

input.addEventListener("input", () => {
  socket.emit("typing", { name: username, typing: true });

  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    socket.emit("typing", { name: username, typing: false });
  }, 1000); // stop typing after 1s of no input
});

socket.on("typing", (data) => {
  const streak = document.getElementById("streak");
  if (data.typing) {
    streak.classList.add("glow");
  } else {
    streak.classList.remove("glow");
  }
});


    form.addEventListener('submit', (e) => {
      e.preventDefault();
      const message = input.value.trim();
      if (message) {
        socket.emit('chat message', { 
          name: username, 
          text: message 
        });
        input.value = '';
      }
    });

    let oldestTimestamp = null;
let loading = false;

socket.on('previous messages', (msgs) => {
  messages.innerHTML = '';
  msgs.forEach(addMessage);

  if (msgs.length > 0) {
    oldestTimestamp = msgs[0].timestamp; // save oldest
  }
});

// Infinite scroll: detect scroll to top
messages.addEventListener('scroll', async () => {
  if (messages.scrollTop === 0 && !loading && oldestTimestamp) {
    loading = true;

    try {
      const res = await fetch(`/messages?before=${oldestTimestamp}&limit=20`);
      const olderMessages = await res.json();

      if (olderMessages.length > 0) {
        // Remember current scroll height
        const prevHeight = messages.scrollHeight;

        // Prepend older messages
        olderMessages.forEach(msg => {
          const msgDiv = document.createElement('div');
          msgDiv.classList.add('message');
          msgDiv.classList.add(msg.name === username ? 'sent' : 'received');
          msgDiv.textContent = msg.text;
          messages.insertBefore(msgDiv, messages.firstChild);
        });

        // Update oldest timestamp
        oldestTimestamp = olderMessages[0].timestamp;

        // Keep scroll in same position
        messages.scrollTop = messages.scrollHeight - prevHeight;
      }
    } catch (err) {
      console.error("Error fetching older messages:", err);
    }

    loading = false;
  }
});


    socket.on('chat message', (msg) => {
      addMessage(msg);
    });

    socket.onAny((event, ...args) => {
      console.log('Socket event:', event, args);
    });

socket.on('reaction:updated', ({ messageId, reactions }) => {
  renderReactions(messageId, reactions);
});


// Fetch current streak when page loads
fetch("/streak")
  .then(res => res.json())
  .then(data => {
    document.getElementById("streak").innerText = `🔥 ${data.count}`;
  })
  .catch(err => console.error("Failed to fetch streak", err));

// Listen for live updates
socket.on("streakUpdated", (data) => {
  document.getElementById("streak").innerText = `🔥 ${data.count}`;
});

  </script>

  <script>
    window.addEventListener('resize', () => {
      const chatInput = document.querySelector('.chat-input');
      if (window.innerHeight < 500) {
        chatInput.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }
    });
  </script>

</body>
</html>